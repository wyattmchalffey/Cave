// DensityDebug.compute - Debug shader for reading density field values
#pragma kernel ReadDensitySlice
#pragma kernel VisualizeDensity

// Input
Texture3D<float4> WorldData;

// Output
RWStructuredBuffer<float> DensityOutput;
RWTexture2D<float4> DebugTexture;

// Parameters
float4 ChunkCoord;
int ChunkSize;
int SliceY;

[numthreads(8, 1, 8)]
void ReadDensitySlice(uint3 id : SV_DispatchThreadID)
{
    // Read a horizontal slice of the density field
    uint3 texCoord = uint3(
        ChunkCoord.x * ChunkSize + id.x,
        ChunkCoord.y * ChunkSize + SliceY,
        ChunkCoord.z * ChunkSize + id.z
    );
    
    float4 data = WorldData[texCoord];
    
    // Output just the density value
    uint index = id.x + id.z * (ChunkSize + 1);
    DensityOutput[index] = data.x; // x = density
}

[numthreads(8, 8, 1)]
void VisualizeDensity(uint3 id : SV_DispatchThreadID)
{
    // Create a 2D visualization of density at a specific Y level
    uint3 texCoord = uint3(
        ChunkCoord.x * ChunkSize + id.x,
        ChunkCoord.y * ChunkSize + SliceY,
        ChunkCoord.z * ChunkSize + id.y
    );
    
    float4 data = WorldData[texCoord];
    float density = data.x;
    
    // Color based on density
    float4 color;
    if (density > 0.1)
    {
        // Solid rock - shades of brown
        color = float4(0.4, 0.3, 0.2, 1.0) * (0.5 + 0.5 * density);
    }
    else if (density > -0.1)
    {
        // Near surface - yellow
        color = float4(1.0, 1.0, 0.0, 1.0);
    }
    else
    {
        // Empty space - blue, darker = more empty
        float emptiness = -density;
        color = float4(0.0, 0.0, 0.3 + 0.7 * (1.0 - emptiness), 1.0);
    }
    
    DebugTexture[id.xy] = color;
}
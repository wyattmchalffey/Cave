// MeshGeneration.compute - Complete GPU Marching Cubes Implementation
#pragma kernel MarchingCubes

// Constants
static const uint CHUNK_SIZE = 32;
static const float VOXEL_SIZE = 0.25;
static const float ISO_LEVEL = 0.0;

// Corner offsets for a voxel cube
static const float3 cornerOffsets[8] = {
    float3(0, 0, 0),
    float3(1, 0, 0),
    float3(1, 0, 1),
    float3(0, 0, 1),
    float3(0, 1, 0),
    float3(1, 1, 0),
    float3(1, 1, 1),
    float3(0, 1, 1)
};

// Edge vertex indices
static const int2 edgeVertices[12] = {
    int2(0, 1), int2(1, 2), int2(2, 3), int2(3, 0),
    int2(4, 5), int2(5, 6), int2(6, 7), int2(7, 4),
    int2(0, 4), int2(1, 5), int2(2, 6), int2(3, 7)
};

// Input/Output buffers
StructuredBuffer<float> DensityField;
AppendStructuredBuffer<float3> Vertices;
AppendStructuredBuffer<float3> Normals;
AppendStructuredBuffer<int> Triangles;

// Lookup tables
StructuredBuffer<int> EdgeTable;
StructuredBuffer<int> TriTable;

// Parameters
float3 ChunkOrigin;
int LODLevel;

// Thread-local storage for generated triangles
groupshared uint vertexCount;

// Helper functions
uint GetDensityIndex(uint3 pos)
{
    return pos.x + pos.y * (CHUNK_SIZE + 1) + pos.z * (CHUNK_SIZE + 1) * (CHUNK_SIZE + 1);
}

float SampleDensity(uint3 pos)
{
    if (pos.x > CHUNK_SIZE || pos.y > CHUNK_SIZE || pos.z > CHUNK_SIZE)
        return 1.0; // Solid outside chunk bounds
    
    return DensityField[GetDensityIndex(pos)];
}

float3 InterpolateVertex(float3 p1, float3 p2, float v1, float v2)
{
    if (abs(ISO_LEVEL - v1) < 0.00001)
        return p1;
    if (abs(ISO_LEVEL - v2) < 0.00001)
        return p2;
    if (abs(v1 - v2) < 0.00001)
        return p1;
    
    float t = (ISO_LEVEL - v1) / (v2 - v1);
    return p1 + t * (p2 - p1);
}

float3 CalculateNormal(float3 localPos)
{
    // Calculate gradient using finite differences
    float h = 1.0; // Sample distance in voxel units
    
    float3 samplePos = localPos / VOXEL_SIZE;
    
    float dx = SampleDensity(uint3(samplePos + float3(h, 0, 0))) -
               SampleDensity(uint3(samplePos - float3(h, 0, 0)));
    float dy = SampleDensity(uint3(samplePos + float3(0, h, 0))) -
               SampleDensity(uint3(samplePos - float3(0, h, 0)));
    float dz = SampleDensity(uint3(samplePos + float3(0, 0, h))) -
               SampleDensity(uint3(samplePos - float3(0, 0, h)));
    
    return normalize(float3(dx, dy, dz));
}

[numthreads(8, 8, 8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    // Skip if outside chunk bounds
    if (id.x >= CHUNK_SIZE || id.y >= CHUNK_SIZE || id.z >= CHUNK_SIZE)
        return;
    
    // Apply LOD
    uint lodStep = 1u << LODLevel;
    if ((id.x % lodStep) != 0 || (id.y % lodStep) != 0 || (id.z % lodStep) != 0)
        return;
    
    // Get corner positions and densities
    float3 cornerPos[8];
    float densities[8];
    
    for (int i = 0; i < 8; i++)
    {
        uint3 corner = id + uint3(cornerOffsets[i] * lodStep);
        cornerPos[i] = float3(corner) * VOXEL_SIZE;
        densities[i] = SampleDensity(corner);
    }
    
    // Determine cube configuration
    int cubeIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        if (densities[i] < ISO_LEVEL)
            cubeIndex |= (1 << i);
    }
    
    // Skip if cube is entirely inside or outside
    int edgeFlags = EdgeTable[cubeIndex];
    if (edgeFlags == 0)
        return;
    
    // Find intersection points on edges
    float3 edgeVerts[12];
    
    for (int i = 0; i < 12; i++)
    {
        if (edgeFlags & (1 << i))
        {
            int2 edge = edgeVertices[i];
            edgeVerts[i] = InterpolateVertex(
                cornerPos[edge.x], 
                cornerPos[edge.y],
                densities[edge.x], 
                densities[edge.y]
            );
        }
    }
    
    // Generate triangles
    for (int i = 0; i < 16; i += 3)
    {
        int triIndex = cubeIndex * 16 + i;
        
        if (TriTable[triIndex] == -1)
            break;
        
        // Get vertex indices from triangle table
        int i0 = TriTable[triIndex];
        int i1 = TriTable[triIndex + 1];
        int i2 = TriTable[triIndex + 2];
        
        // Add vertices with world position
        float3 v0 = edgeVerts[i0] + ChunkOrigin;
        float3 v1 = edgeVerts[i1] + ChunkOrigin;
        float3 v2 = edgeVerts[i2] + ChunkOrigin;
        
        // Calculate normals (using local position for gradient)
        float3 n0 = CalculateNormal(edgeVerts[i0]);
        float3 n1 = CalculateNormal(edgeVerts[i1]);
        float3 n2 = CalculateNormal(edgeVerts[i2]);
        
        // Append vertices and normals
        Vertices.Append(v0);
        Vertices.Append(v1);
        Vertices.Append(v2);
        
        Normals.Append(n0);
        Normals.Append(n1);
        Normals.Append(n2);
        
        // For triangles, we'll just append sequential indices
        // The CPU side will interpret every 3 vertices as a triangle
        Triangles.Append(0); // Placeholder - actual indices handled CPU-side
        Triangles.Append(0);
        Triangles.Append(0);
    }
}
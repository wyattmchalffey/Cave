// SimpleMeshExtraction.compute - Simplified marching cubes for testing
#pragma kernel ExtractMesh

// World data texture
Texture3D<float4> WorldData;

// Output buffers - using structured buffers instead of append
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Indices;
RWStructuredBuffer<int> VertexCount; // Single element buffer to track count

// Chunk parameters
float4 ChunkCoord;
float VoxelSize;
int ChunkSize;

// Constants
static const float ISO_LEVEL = 0.0;

// Sample density from world
float SampleDensity(int3 coord)
{
    int3 texCoord;
    texCoord.x = (int)(ChunkCoord.x * ChunkSize) + coord.x;
    texCoord.y = (int)(ChunkCoord.y * ChunkSize) + coord.y;
    texCoord.z = (int)(ChunkCoord.z * ChunkSize) + coord.z;
    
    return WorldData[texCoord].x;
}

[numthreads(8, 8, 8)]
void ExtractMesh(uint3 id : SV_DispatchThreadID)
{
    // Only process interior voxels
    if (id.x >= (uint)(ChunkSize - 1) || id.y >= (uint)(ChunkSize - 1) || id.z >= (uint)(ChunkSize - 1))
        return;
    
    // Convert uint3 to int3 for sampling
    int3 baseCoord;
    baseCoord.x = (int)id.x;
    baseCoord.y = (int)id.y;
    baseCoord.z = (int)id.z;
    
    // Sample the 8 corners of this voxel
    float d000 = SampleDensity(baseCoord);
    float d100 = SampleDensity(baseCoord + int3(1, 0, 0));
    float d010 = SampleDensity(baseCoord + int3(0, 1, 0));
    float d001 = SampleDensity(baseCoord + int3(0, 0, 1));
    
    // Simple case: check if this voxel crosses the surface
    bool inside000 = d000 < ISO_LEVEL;
    bool inside100 = d100 < ISO_LEVEL;
    bool inside010 = d010 < ISO_LEVEL;
    bool inside001 = d001 < ISO_LEVEL;
    
    // If all corners are the same, skip
    if (inside000 == inside100 && inside000 == inside010 && inside000 == inside001)
        return;
    
    // Generate a simple quad at surface crossing
    float3 worldOffset = ChunkCoord.xyz * ChunkSize * VoxelSize;
    float3 voxelPos = float3(id) * VoxelSize + worldOffset;
    
    // Allocate vertices atomically
    int vertexIndex = 0;
    InterlockedAdd(VertexCount[0], 6, vertexIndex);
    
    // Don't exceed buffer size
    if (vertexIndex + 6 > 65535)
        return;
    
    // Create two triangles forming a quad
    float3 v0 = voxelPos;
    float3 v1 = voxelPos + float3(VoxelSize, 0, 0);
    float3 v2 = voxelPos + float3(VoxelSize, 0, VoxelSize);
    float3 v3 = voxelPos + float3(0, 0, VoxelSize);
    
    // Calculate normal (pointing up for now)
    float3 normal = float3(0, 1, 0);
    
    // First triangle
    Vertices[vertexIndex + 0] = v0;
    Vertices[vertexIndex + 1] = v1;
    Vertices[vertexIndex + 2] = v2;
    
    Normals[vertexIndex + 0] = normal;
    Normals[vertexIndex + 1] = normal;
    Normals[vertexIndex + 2] = normal;
    
    Indices[vertexIndex + 0] = vertexIndex + 0;
    Indices[vertexIndex + 1] = vertexIndex + 1;
    Indices[vertexIndex + 2] = vertexIndex + 2;
    
    // Second triangle
    Vertices[vertexIndex + 3] = v0;
    Vertices[vertexIndex + 4] = v2;
    Vertices[vertexIndex + 5] = v3;
    
    Normals[vertexIndex + 3] = normal;
    Normals[vertexIndex + 4] = normal;
    Normals[vertexIndex + 5] = normal;
    
    Indices[vertexIndex + 3] = vertexIndex + 3;
    Indices[vertexIndex + 4] = vertexIndex + 4;
    Indices[vertexIndex + 5] = vertexIndex + 5;
}